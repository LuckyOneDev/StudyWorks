/******************************************************************************
*                              Курс информатики                               *
*******************************************************************************
* Project Type  : Win32 Console Application                                   *
* Project Name  : Generation of various sequences                             *
* File Name     : K2L2.cpp                                                    *
* Language      : c++, MSVS ver 2015 and above                                *
* Programmers   : Парфенюк Дмитрий Александрович, Мокшин Иван Николаевич      *
* Modified by   :                                                             *
* Created       : 19.09.2021                                                  *
* Last Revision :                                                             *
******************************************************************************/

#include <iostream>
#include <ctime>
#include <fstream>
#include <chrono>
#include <iomanip>

int Better_Linear_Search(int* arr, int arrSize, int key, int* compareCount = NULL, bool compareTest = false) {

    if (compareTest) {
        *compareCount = 0;

        (*compareCount)++; //i < arrSiz
        for (int i = 0; i < arrSize; i++)
        {
            (*compareCount)++; //i < arrSize

            (*compareCount)++; //arr[i] == key
            if (arr[i] == key) {
                return i;
            }

        }
        return -1;
    }
    else {
        for (int i = 0; i < arrSize; i++)
        {
            if (arr[i] == key) {
                return i;
            }
        }
        return -1;
    }
}

int Sentinel_Linear_Search(int* arr, int arrSize, int key, int* compareCount = NULL, bool compareTest = false) {
    
    if (compareTest) {
        *compareCount = 0;

        int last = arr[arrSize - 1];
        arr[arrSize - 1] = key;
        int i = 0;

        (*compareCount)++; //arr[i] != key
        while (arr[i] != key) {
            (*compareCount)++; //arr[i] != key
            i++;
        }

        arr[arrSize - 1] = last;

        (*compareCount)++; //(i < arrSize - 1) || (arr[arrSize - 1] == key)
        if ((i < arrSize - 1) || (arr[arrSize - 1] == key))
            return i;
        else
            return -1;
    }
    else {
        int last = arr[arrSize - 1];
        arr[arrSize - 1] = key;
        int i = 0;

        while (arr[i] != key) {
            i++;
        }

        arr[arrSize - 1] = last;

        if ((i < arrSize - 1) || (arr[arrSize - 1] == key))
            return i;
        else
            return -1;
    }

}

int Sequential_Linear_Search(int* arr, int arrSize, int key, int* compareCount = NULL, bool compareTest = false) {
    
    if (compareTest) {
        (*compareCount) = 0;

        int i = 1;
        (*compareCount)++; //key > arr[i]
        while (key > arr[i]) {
            i++;
            (*compareCount)++; //key > arr[i]
        }

        (*compareCount)++;
        if (key == arr[i])
        {
            return i;
        }
        return -1;
    }
    else {
        int i = 1;
        while (key > arr[i]) {
            i++;
        }

        if (key == arr[i])
        {
            return i;
        }
        return -1;
    }
    
}

int Binary_search(int* arr, int arrSize, int key, int* compareCount = NULL, bool compareTest = false) {
    
    if (compareTest) {
        *compareCount = 0;

        // Lecture realization
        int lo = 0;
        int hi = arrSize - 1;
        int mi;
        (*compareCount)++;  //lo < hi
        while (lo < hi)
        {
            (*compareCount)++; //lo < hi

            mi = (lo + hi) / 2;
            (*compareCount)++;; //arr[mi] == key
            if (arr[mi] == key) {
                return mi;
            }

            (*compareCount)++;
            if (arr[mi] < key) {
                lo = mi + 1;
            }
            else {
                hi = mi - 1;
            }
        }

    }
    else {
        // Lecture realization
        int lo = 0;
        int hi = arrSize - 1;
        int mi;
        while (lo < hi)
        {
            mi = (lo + hi) / 2;
            if (arr[mi] == key) {
                return mi;
            }

            if (arr[mi] < key) {
                lo = mi + 1;
            }
            else {
                hi = mi - 1;
            }
        }
    }
   
}

//Генерирует случайную возрастающую последовательность
//size - размер нужного массива
//Возвращает arr - указатель на массив
int* generateIncreaseSequence(int size) {
    int* arr = new int[size]; //Выделение памяти
    int step = 5; // Вычисление шага
    for (int i = 0; i < size; i++)
        arr[i] = i * step + rand() % step;  //Заполнение массива
    return arr;
}

//Генерирует случайную последовательность от 0 до INT_MAX
//size - размер нужного массива
//Возвращает arr - указатель на массив
int* generateRandomSequence(int size) {
    int* arr = new int[size]; //Выделение памяти
    for (int i = 0; i < size; i++)
        arr[i] = rand();  //Заполнение массива
    return arr;
}

inline int randintinrng(int min, int max) {
    return min + (rand() % max - min + 1);
}

int main() {
    //Инициализация рандомизатора
    srand(time(NULL));

    int* increaseSequence = generateIncreaseSequence(30);
    int* randomSequence = generateRandomSequence(30);

    //Тестирование функций на работоспособность
    const int fcount = 4;
    const char** fnames = new const char*[4]{ 
        "Better_Linear_Search\0", 
        "Sentinel_Linear_Search\0", 
        "Sequential_Linear_Search\0", 
        "Binary_search\0"
    };
    int (*funcs[])(int*, int, int, int*, bool) = {
        Better_Linear_Search,
        Sentinel_Linear_Search,
        Sequential_Linear_Search,
        Binary_search
    };

    int index = randintinrng(0, 30);

    std::cout << "Index: " << index << std::endl;
    for (int i = 0; i < 2; i++)
    {
        int comparecount = 0;
        int found = funcs[i](randomSequence, 30, randomSequence[index], &comparecount, true);
        std::cout << fnames[i] << ": ";
        if (found == index) std::cout << "OK. "; else std::cout << "NOT OK. ";
        std::cout << "Comparecount: " << comparecount;
        std::cout << std::endl;
    }

    for (int i = 2; i < fcount; i++)
    {
        int comparecount = 0;
        int found = funcs[i](increaseSequence, 30, increaseSequence[index], &comparecount, true);
        std::cout << std::setw(10) << fnames[i] << ": ";
        if (found == index) std::cout << "OK. "; else std::cout << "NOT OK. ";
        std::cout << "Comparecount: " << comparecount;
        std::cout << std::endl;
    }

    const int bigsize = 500000;

    int* BigrandomSequence = generateRandomSequence(bigsize);
    int* BigincreaseSequence = generateIncreaseSequence(bigsize);
    

    std::cout << "Sequences generated" << std::endl;

    //Тесты
    const int testCount = 100000;
    int* testSet = new int[testCount];

    std::ofstream ofs("tests.csv", std::ofstream::out | std::ofstream::app);

    //Формирование тестового набора
    ofs << "Value;";
    for (int i = 0; i < testCount; i++) {
        testSet[i] = rand();
        ofs << testSet[i] << ';';
    }
    ofs << '\n';

    for (int i = 0; i < 2; i++) {
        
        bool* answerSet = new bool[testCount];

        ofs << fnames[i] << ';';

        for (int j = 0; j < testCount; j++) {

            auto beginTime = std::chrono::steady_clock::now();
            int result = funcs[i](BigrandomSequence, bigsize, testSet[j], NULL, false);
            answerSet[j] = result != -1;
            auto endTime = std::chrono::steady_clock::now();

            auto elapsedMs = std::chrono::duration_cast<std::chrono::microseconds>(endTime - beginTime).count();

            ofs << elapsedMs << ';';
        }

        ofs << '\n' << "Ans;";
        for (int j = 0; j < testCount; j++) {
            ofs << answerSet[j] << ';';
        }
        delete[] answerSet;
        ofs << '\n';
    }

    for (int i = 2; i < fcount; i++) {
        bool* answerSet = new bool[testCount];

        ofs << fnames[i] << ';';

        for (int j = 0; j < testCount; j++) {

            auto beginTime = std::chrono::steady_clock::now();
            int result = funcs[i](BigincreaseSequence, bigsize, testSet[j], NULL, false);
            answerSet[j] = result != -1;
            auto endTime = std::chrono::steady_clock::now();

            auto elapsedMs = std::chrono::duration_cast<std::chrono::microseconds>(endTime - beginTime).count();

            ofs << elapsedMs << ';';
        }

        ofs << '\n' << "Ans;";
        for (int j = 0; j < testCount; j++) {
            ofs << answerSet[j] << ';';
        }
        delete[] answerSet;
        ofs << '\n';
    }

}
/**********************************END-OF-K2L2.CPP******************************/
